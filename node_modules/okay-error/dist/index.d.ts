export type Ok<ValueType> = {
    readonly ok: true;
    readonly value: ValueType;
    readonly error?: undefined;
};
export type Err<ErrorType = unknown> = {
    readonly ok: false;
    readonly error: ErrorType;
    readonly value?: undefined;
};
/**
 * Union type representing either a successful (Ok) or failed (Err) computation result.
 *
 * @typeparam ValueType - The type of the value in a successful result
 * @typeparam ErrorType - The type of the error in a failed result
 */
export type Result<ValueType, ErrorType = unknown> = Ok<ValueType> | Err<ErrorType>;
/**
 * Construct a successful Result containing a value.
 *
 * @example
 * const success = ok(42)
 * console.log(success.value) // 42
 */
export declare function ok<T>(value: T): Ok<T>;
/**
 * Construct a successful Result with undefined value.
 *
 * @example
 * const success = ok()
 * console.log(success.value) // undefined
 */
export declare function ok(): Ok<undefined>;
/**
 * Construct an error Result with a type and payload.
 *
 * @example
 *   err('Timeout', { ms: 1000 }) // Err<{ type: 'Timeout', ms: 1000 }>
 */
export declare function err<K extends string, P extends Record<string, unknown>>(type: K, payload: P): Err<{
    type: K;
} & P>;
/**
 * Construct an error Result with only a type.
 *
 * @example
 *   err('Timeout') // Err<{ type: 'Timeout' }>
 */
export declare function err<K extends string>(type: K): Err<K>;
/**
 * Construct an error Result from an arbitrary error value (object, string, etc).
 * Type safety and pattern matching only work if the value is an object with a `type` property.
 *
 * @example
 *   err({ message: 'Something failed' })
 *   err(new Error('fail'))
 */
export declare function err<K>(payload: K): Err<K>;
/**
 * Helper to embed a cause error payload when constructing a new Err.
 *
 * @example
 * const low = err('Low')
 * const high = err('High', cause(low))
 */
export declare function cause<T extends {
    error: any;
}>(e: T): {
    cause: T["error"];
};
export declare const map: <ValueType, NewValue, ErrorType = unknown>(r: Result<ValueType, ErrorType>, fn: (v: ValueType) => NewValue) => Result<NewValue, ErrorType>;
export declare const mapErr: <ValueType, ErrorType, NewError>(r: Result<ValueType, ErrorType>, fn: (e: ErrorType) => NewError) => Result<ValueType, NewError>;
export declare const flatMap: <ValueType, NewValue, ErrorType = unknown>(r: Result<ValueType, ErrorType>, fn: (v: ValueType) => Result<NewValue, ErrorType>) => Result<NewValue, ErrorType>;
export declare const unwrap: <ValueType, ErrorType = unknown>(r: Result<ValueType, ErrorType>) => ValueType;
export declare const orElse: <ValueType, ErrorType = unknown>(r: Result<ValueType, ErrorType>, fallback: ValueType) => ValueType;
export declare function result<ValueType>(work: () => ValueType): Result<ValueType>;
export declare function result<ValueType, ErrorType = unknown>(work: PromiseLike<ValueType>): Promise<Result<ValueType, ErrorType>>;
/**
 * Pattern match on a Result object (Ok/Err) or a discriminant string.
 *
 * Overloads:
 * - match(result, { ok, err })
 * - match(type, { A: fn, B: fn })
 */
export declare function match<ValueType, ErrorType, OnOk, OnErr>(r: Result<ValueType, ErrorType>, arms: {
    ok: (v: ValueType) => OnOk;
    err: (e: ErrorType) => OnErr;
}): OnOk | OnErr;
export declare function match<T extends string & (string extends T ? never : unknown), Cases extends {
    [K in T]: () => unknown;
}>(value: T, cases: Cases & Record<Exclude<keyof Cases, T>, never>): ReturnType<Cases[keyof Cases]>;
